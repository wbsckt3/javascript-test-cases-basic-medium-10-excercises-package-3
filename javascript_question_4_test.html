<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refactorii</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/8.4.0/mocha.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.6.3/dist/vuetify.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>  
    <link rel="stylesheet" href="https://wbsckt3.github.io/mocha_test_cases_styles_2/style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.6.3/dist/vuetify.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuex@3.6.2/dist/vuex.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/8.4.0/mocha.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/4.3.4/chai.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/javascript/javascript.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jwt-decode@4.0.0/build/cjs/index.min.js"></script>
</head>
<body>
    <div id="editor-container">
        <textarea id="code-editor">
const shape = {
/* Challenge: Create a Flexible Sequence Generator
Challenge Description
Develop a function that generates a sequence based on a given pattern, which can either be a static value or a dynamic function. This function should handle both cases to produce the desired sequence.
Specifications
Function: shape.sequence
Parameters:
n: The number of elements in the sequence.
pattern: A static value or a function to determine the values in the sequence.
Returns: An array of length n where each element is determined by the pattern.
Behavior:
If pattern is a static value: The function should return an array where every element is the same as the pattern.
If pattern is a function: The function should be called for each element in the sequence. Use the index of the element in the sequence as an argument to the function, and the function's return value should be used for that element.
Example Scenarios
Static Value Example:
Input: shape.sequence(4, 'A')
Output: ['A', 'A', 'A', 'A']
Function Example:
Input: shape.sequence(3, (element, index) => index * 10)
Output: [0, 10, 20]
Objective
Implement the sequence function within the shape object to dynamically generate sequences based on the provided pattern, accommodating both static values and functions. */
};

// Test cases
console.log(shape.changeTime('10:00', 1));    // '10:01'
console.log(shape.changeTime('10:00', -1));   // '09:59'
console.log(shape.changeTime('23:59', 1));    // '00:00'
console.log(shape.changeTime('00:00', -1));   // '23:59'

        </textarea>
	<img id="logo" src="https://wbsckt3.github.io/javascript-test-cases-basic-medium-10-excercises-package/logo_refactorii.png" alt="Logo Refactorii">
        <button id="run-button">Run</button>
    </div>
    <div id="app-container">
        <div id="app">
	    <h5>Exercice 4: String Manipulation</h5>
            <div id="modify-message">The changeTime function takes a time string in the format 'HH:MM' and splits ... </div>
	    <button id="send-response-button" onClick= "guardarResultados()">Send Response</button>
        </div>
    </div>
    <div id="console-container"><div id="console"></div></div>
    <div id="mocha-container"><div id="mocha"></div></div>
    <script>mocha.setup('bdd');</script>

    <!-- Modal -->
    <div class="modal fade" id="errorMessageModal" tabindex="-1" role="dialog" aria-labelledby="errorMessageModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="errorMessageModalLabel">Concept</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body" id="errorMessageModalBody">
                    <!-- Contenido del mensaje de error -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
    <script>
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    if (token) {
	    // Realiza una solicitud al servicio externo para validar el token
	    fetch(`https://www.refactorii.com/validate-token?token=${token}`)
	    .then(response => response.json())
	    .then(data => {
	        if (data.valid) {
	            console.log(data.valid);
	             // Decodifica el token para obtener el payload
                     const decodedToken = decodeJwtResponse(token);
         	     const recipeId = decodedToken._id; // Aseg√∫rate de usar el nombre correcto del campo en el payload
                     console.log('Recipe ID:', recipeId);
		     // Almacenar recipeId en local storage
                     localStorage.setItem('recipeId', recipeId);
	             // Llama a la funci√≥n de prueba
	             test_cases_scenario();
	        } else {
	            console.log(data.valid);
	            document.body.innerHTML = 'Access denied. Invalid token.';
	        }
	    }).catch(error => {
	        document.body.innerHTML = 'Error validating token.';
	        console.error('Error:', error);
	    });
    } else {
	    document.body.innerHTML = 'Access denied. No token provided.';
    }
    function test_cases_scenario(){	    
        const editor = CodeMirror.fromTextArea(document.getElementById('code-editor'), {
            lineNumbers: true,
            mode: 'javascript',
            lineWrapping: true,
            scrollbarStyle: 'null'
        });
        
        var modal_click_message = `The solution involves several key concepts in JavaScript programming...`;
        var error_message = `Concept Explanation:\n
The solution involves several key concepts in JavaScript programming:<br><br>
Object-Oriented Design:<br>
The function changeTime is encapsulated within an object called shape. This is a common pattern in JavaScript where functions are grouped together in an object to represent a cohesive unit or module.\n
<br><br>
String Manipulation:<br>
The changeTime function takes a time string in the format 'HH:MM' and splits it into hours and minutes using the split(':') method. This method splits the string into an array based on the colon ':' separator.\n
<br><br>
Array and Number Manipulation:<br>
The resulting array from split(':') contains string representations of the hours and minutes, which are then converted to numbers using map(Number). This ensures that arithmetic operations can be performed on these values.\n
<br><br>
Handling Minute Overflow and Underflow:<br>
When the delta value is added to the minutes, the function checks if the minutes exceed 59 (overflow) or drop below 0 (underflow). If there is an overflow, the function subtracts 60 from the minutes and increments the hour. If there is an underflow, it adds 60 to the minutes and decrements the hour.
<br><br>
Handling Hour Overflow and Underflow:<br>
Similarly, the function checks for hour overflow and underflow. If the hours exceed 23, it wraps around to 0 (indicating midnight). If the hours drop below 0, it wraps around to 23 (indicating the last hour of the previous day).\n
<br><br>
Formatting Output:<br>
The output time is formatted as 'HH:MM', with leading zeros added if necessary. This is done using the padStart(2, '0') method, which ensures that the hours and minutes are always two digits long.\n
<br><br>
Example Usage:<br>
The function is tested with different cases:
<br><br>
Increasing the time by 1 minute.<br>
Decreasing the time by 1 minute.<br>
Handling the transition from 23:59 to 00:00.<br>
Handling the transition from 00:00 to 23:59.<br>
These cases demonstrate the function's ability to correctly adjust the time while handling boundary conditions.`;  
	var success_message = `üéâüéâ Congratulations! You've successfully completed the test! üöÄüëè Keep up the great work and continue pushing your limits. You're doing amazing! 
       üåü #KeepCoding #AchievementUnlocked üéâüéâ`
        
        // Funci√≥n para mostrar el modal con el mensaje de error
        document.getElementById('modify-message').addEventListener('click', function() {
            $('#errorMessageModalBody').html(error_message); // Coloca el contenido del error en el cuerpo del modal
            $('#errorMessageModal').modal('show'); // Muestra el modal
        });

        function logToConsole(message, color) {
            const consoleElement = document.getElementById('console');
            const messageElement = document.createElement('div');
            messageElement.textContent = message;
            if (color) {
                messageElement.style.color = color;
                messageElement.style.fontWeight = 'bold';
            }
            consoleElement.appendChild(messageElement);
        }

        document.getElementById('run-button').addEventListener('click', function() {
            // Clear previous results
            document.getElementById('console').innerHTML = '';
            document.getElementById('mocha').innerHTML = '';
            mocha.suite.suites = []; // Clear previous test cases
            // Get the user's code from the editor
            const userCode = editor.getValue();
            // Redirect console.log to custom console
	    const output = [];
	    const originalConsoleLog = console.log;
	    console.log = function(message) {
		output.push(message);
		logToConsole(message);
	    };
	    // Show "Ejecutando tests..." message and delay tests
	    logToConsole('Running tests...', 'blue');
  	    setTimeout(() => {
            	// Evaluate the user's code
            	try {
                    const userFunction = new Function(userCode + '; return shape;');
                    const shape = userFunction();
                    // Define test cases
                    const expect = chai.expect;
                    

describe('shape.changeTime()', function() {

   let loggedValues;
  let originalConsoleLog;

  beforeEach(function() {
    // Almacenar la funci√≥n original de console.log y los valores registrados
    loggedValues = [];
    originalConsoleLog = console.log;
    console.log = (...args) => {
      loggedValues.push(args[0]); // Captura el valor registrado
      originalConsoleLog.apply(console, args); // Llama al original console.log
    };
  });

  afterEach(function() {
    // Restaura console.log despu√©s de cada prueba
    console.log = originalConsoleLog;
  });
	
  it('should increase time by 1 minute', function() {
    const result = shape.changeTime('10:00', 1);
    expect(result).to.equal('10:01');
  });

  it('should decrease time by 1 minute', function() {
    const result = shape.changeTime('10:00', -1);
    expect(result).to.equal('09:59');
  });

  it('should roll over to next hour correctly', function() {
    const result = shape.changeTime('23:59', 1);
    expect(result).to.equal('00:00');
  });

  it('should roll back to previous day correctly', function() {
    const result = shape.changeTime('00:00', -1);
    expect(result).to.equal('23:59');
  });
});
			
		// Variable para rastrear el estado de los tests
                let allTestsPassed = true;	
                // Run Mocha tests
                mocha.run()
                    .on('test', function(test) {
                        logToConsole('‚Ä¢ Running test: ' + test.title);
                    })
                    .on('test end', function(test) {
                        logToConsole('‚Ä¢ Test finished: ' + test.title);
                    })
                    .on('pass', function(test) {
                        logToConsole('‚Ä¢ Test passed: ' + test.title);
                    })
                    .on('fail', function(test, err) {
			logToConsole('‚Ä¢ Test failed: ' + test.title + ' - ' + err.message);
			success_message = modal_click_message;
			const runButton = document.getElementById('run-button');
			runButton.innerText = 'Retry';
			runButton.style.backgroundColor = '#ff0000ad';
			runButton.onclick = function() {
			    window.location.reload();
			};
			allTestsPassed = false; // Si cualquier test falla, actualizamos la variable	
		     })
		     .on('end', function() {
			logToConsole('‚Ä¢ All tests finished!');
			document.getElementById('modify-message').innerText = success_message;
			document.getElementById('modify-message').style.display = 'block';
			document.getElementById('modify-message').style.color = 'black';
			if (allTestsPassed) {
		               const sendResponseButton = document.getElementById('send-response-button');
		               sendResponseButton.classList.add('enabled');
		        } 
		     });

            } catch (e) {
                console.error('Error evaluating user code:', e);
                logToConsole('Error: ' + e.message, 'red');
            } finally {
                // Restore original console.log
                console.log = originalConsoleLog;
            }
			
		}, 3000); // 3 seconds delay
        });
    }
	    
    async function guardarResultados() {
	    const formData = JSON.parse(localStorage.getItem("formData"));
	    const email = formData ? formData.Email : null;
            const recipeId = localStorage.getItem('recipeId'); // Recuperar recipeId de local storage
	    // Crear el objeto que se guardar√° en la base de datos
	    // Obtener la URL actual
	    const currentUrl = window.location.href;
	    // Crear un objeto URL
	    const url = new URL(currentUrl);
	    // Eliminar el par√°metro 'token' de la query string
	    url.searchParams.delete('token');
	    // Obtener el pathname sin el token
            const urlWithoutToken = url.pathname.split('/').pop();
	    const recipeCalificadaOk = {
	        recipeId: recipeId,
		url: urlWithoutToken,
	        date: new Date().toISOString()
	    };
	    try {
	        const response = await fetch('https://www.refactorii.com/updateOneGoogleSigninUserRecipe', {
	            method: 'POST',
	            headers: {
	                'Content-Type': 'application/json'
	            },
	            //body: JSON.stringify({ Email: email, recipeCalificadaOk: recipeId })
		    body: JSON.stringify({ Email: email, recipeCalificadaOk })	
	        });
	        const data = await response.json();
	        console.log('Server responds:', "Ok");
		// Redirecci√≥n a la p√°gina original
                window.location.href = `https://www.refactorii.com/recipes/${recipeId}`;
	    } catch (error) {
	        console.error('Error sending the results to the server:', error);
	    }
    }

    function decodeJwtResponse(token) {
	    var base64Url = token.split('.')[1];
	    var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
	    var jsonPayload = decodeURIComponent(window.atob(base64).split('').map(function(c) {
	        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	    }).join(''));
	    return JSON.parse(jsonPayload);
    }
    </script>
</body>
</html>
