<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refactorii</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/8.4.0/mocha.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.6.3/dist/vuetify.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>  
    <link rel="stylesheet" href="https://wbsckt3.github.io/mocha_test_cases_styles_2/style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.6.3/dist/vuetify.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuex@3.6.2/dist/vuex.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/8.4.0/mocha.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/4.3.4/chai.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/javascript/javascript.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jwt-decode@4.0.0/build/cjs/index.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sinon.js/13.0.1/sinon.min.js"></script>
</head>
<body>
    <div id="editor-container">
        <textarea id="code-editor">
function adviseBefore(target, advice) {
/* Challenge: Create an Advice Function Wrapper
Description:
You need to develop a higher-order function named adviseBefore that takes two arguments: a target function (target) and an advice function (advice). This higher-order function should return a new function that:
Executes the advice function before the target function.
Allows the advice function to modify the arguments passed to the target function.
Specifications
Parameters:
target: The original function that will be called after the advice function.
advice: A function that is executed before the target function and can modify its arguments.
Behavior:
When the returned function is called, it first calls the advice function with the same arguments.
The advice function can return a new set of arguments to be passed to the target function.
If the advice function returns an array, these should be used as the new arguments for the target function. If it does not return an array, the original arguments should be used. */
}
// Test case
const originalFunction = function(...args) {
    console.log('Original function called with args:', ...args);
    return args.join(', ');
};						  
const adviceFunction = function(...args) {
    console.log('Advice function called with args:', ...args);
    // Cambia los argumentos
    return ['Advised argument 1', 'Advised argument 2'];
};
const advisedFn = adviseBefore(originalFunction, adviceFunction);
// Test case
const result = advisedFn('Test arg 1', 'Test arg 2');
console.log(result); // Deber√≠a mostrar 'Advised argument 1, Advised argument 2'

        </textarea>
	<img id="logo" src="https://wbsckt3.github.io/javascript-test-cases-basic-medium-10-excercises-package/logo_refactorii.png" alt="Logo Refactorii">
        <button id="run-button">Run</button>
    </div>
    <div id="app-container">
        <div id="app">
	    <strong>Challenge: Aspect-Oriented Programming (AOP)</strong>
            <p id="modify-message" style="font-size: 13px;">Aspect-oriented programming (AOP) allows adding additional behavior...</p>																																	 
	    <button id="send-response-button" onClick= "guardarResultados()">Send response</button>
        </div>
    </div>
    <div id="console-container"><div id="console"></div></div>
    <div id="mocha-container"><div id="mocha"></div></div>
    <script>mocha.setup('bdd');</script>

    <!-- Modal -->
    <div class="modal fade" id="errorMessageModal" tabindex="-1" role="dialog" aria-labelledby="errorMessageModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="errorMessageModalLabel">Concept</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body" id="errorMessageModalBody">
                    <!-- Contenido del mensaje de error -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    if (token) {
	    // Realiza una solicitud al servicio externo para validar el token
	    fetch(`https://www.refactorii.com/validate-token?token=${token}`)
	    .then(response => response.json())
	    .then(data => {
	        if (data.valid) {
	            console.log(data.valid);
	             // Decodifica el token para obtener el payload
                     const decodedToken = decodeJwtResponse(token);
         	     const recipeId = decodedToken._id; // Aseg√∫rate de usar el nombre correcto del campo en el payload
                     console.log('Recipe ID:', recipeId);
		     // Almacenar recipeId en local storage
                     localStorage.setItem('recipeId', recipeId);
	             // Llama a la funci√≥n de prueba
	             test_cases_scenario();
	        } else {
	            console.log(data.valid);
	            document.body.innerHTML = 'Access denied. Invalid token.';
	        }
	    }).catch(error => {
	        document.body.innerHTML = 'Error validating token.';
	        console.error('Error:', error);
	    });
    } else {
	    document.body.innerHTML = 'Access denied. No token provided.';
    }
    function test_cases_scenario(){	    
        const editor = CodeMirror.fromTextArea(document.getElementById('code-editor'), {
            lineNumbers: true,
            mode: 'javascript',
            lineWrapping: true,
            scrollbarStyle: 'null'
        });
        
        var modal_click_message = `Aspect-oriented programming (AOP) allows adding additional behavior...`;
        var error_message = `Aspect-oriented programming (AOP) allows adding additional behavior (advice) to existing functionality without modifying the functionality itself. Your task is to create a method called adviseBefore which takes two arguments: a target function (target) and an advising function (advice).
The adviseBefore method should return a new function that executes the advising function first, followed by the original method. 
<br><br>The requirements are:
- The arguments passed to the returned function should be passed to the advising function.<br>
- If the advising function returns an array, this array should replace the arguments passed to the original method.<br>
- If the advising function does not return an array, the original arguments should be passed to the original method.<br>
- The return value of the original method should be returned.<br><br>
This exercise tests your ability to work with higher-order functions, argument manipulation, and function composition in JavaScript.`;       
	var success_message = `üëè Fantastic work on conquering the challenge! üåà‚ú® Your skills are growing stronger every day. Now, don't hesitate‚Äîsend in your solution and celebrate 
        your progress! üöÄüìö #KeepLearning #GreatJob`
        
        // Funci√≥n para mostrar el modal con el mensaje de error
        document.getElementById('modify-message').addEventListener('click', function() {
            $('#errorMessageModalBody').html(error_message); // Coloca el contenido del error en el cuerpo del modal
            $('#errorMessageModal').modal('show'); // Muestra el modal
        });

        function logToConsole(message, color) {
            const consoleElement = document.getElementById('console');
            const messageElement = document.createElement('div');
            messageElement.textContent = message;
            if (color) {
                messageElement.style.color = color;
                messageElement.style.fontWeight = 'bold';
            }
            consoleElement.appendChild(messageElement);
        }

        document.getElementById('run-button').addEventListener('click', function() {
            // Clear previous results
            document.getElementById('console').innerHTML = '';
            document.getElementById('mocha').innerHTML = '';
            mocha.suite.suites = []; // Clear previous test cases
            // Get the user's code from the editor
            const userCode = editor.getValue();
            // Redirect console.log to custom console
	    const output = [];
	    const originalConsoleLog = console.log;
	    console.log = function(message) {
		output.push(message);
		logToConsole(message);
	    };
	    // Show "Ejecutando tests..." message and delay tests
	    logToConsole('Running tests...', 'blue');
  	    setTimeout(() => {
            	// Evaluate the user's code
            	try {
                    const userFunction = new Function(userCode + '; return adviseBefore;');
                    const adviseBefore = userFunction();
                    // Define test cases
                    const expect = chai.expect;
                    describe('JavaScript Code Tests', function() {

  let loggedValues; 
  let originalConsoleLog;

  beforeEach(function() {
    // Almacenar la funci√≥n original de console.log y los valores registrados
    loggedValues = [];
    originalConsoleLog = console.log;
    console.log = (...args) => {
      loggedValues.push(args[0]); // Captura el valor registrado
      originalConsoleLog.apply(console, args); // Llama al original console.log
    };
  });

  afterEach(function() {
    // Restaura console.log despu√©s de cada prueba
    console.log = originalConsoleLog;
  });
                    
		    it('should execute without errors', function(done) {
                        try {
                            new Function(userCode)();
                            done();
                        } catch (e) {
                            done(e);
                        }
                    });
                    it('should return a function', function () {
                            const adviceBeforeReturn = adviseBefore(() => { }, () => { });
                            expect(adviceBeforeReturn).to.be.a('function');
                        });

                        it('should modify arguments when advice function returns an array', function () {
                            const originalFunction = function (...args) {
                                return args;
                            };
                            const adviceFunction = function () {
                                return ['advised arg1', 'advised arg2'];
                            };
                            const advisedFn = adviseBefore(originalFunction, adviceFunction);
                            const result = advisedFn('original arg1', 'original arg2');
                            expect(result).to.deep.equal(['advised arg1', 'advised arg2']);
                        });

                        it('should not modify arguments when advice function does not return an array', function () {
                            const originalFunction = function (...args) {
                                return args;
                            };
                            const adviceFunction = function () {
                                return 'not an array';
                            };
                            const advisedFn = adviseBefore(originalFunction, adviceFunction);
                            const result = advisedFn('original arg1', 'original arg2');
                            expect(result).to.deep.equal(['original arg1', 'original arg2']);
                        });

                        it('should call advice function first and then original function', function () {
                            const calls = [];
                            const originalFunction = function () {
                                calls.push('original');
                            };
                            const adviceFunction = function () {
                                calls.push('advice');
                            };
                            const advisedFn = adviseBefore(originalFunction, adviceFunction);
                            advisedFn();
                            expect(calls).to.deep.equal(['advice', 'original']);
                        });

                        it('should print "Refactorii, 21"', function () {
                            const adviceBeforeReturn = adviseBefore(
                                (name, age) => console.log(`${name}, ${age}`),
                                (name, age) => [name, age]
                            );
                            const consoleSpy = sinon.spy(console, 'log');
                            adviceBeforeReturn('Refactorii', 21);
                            expect(consoleSpy.calledWith('Refactorii, 21')).to.be.true;
                            consoleSpy.restore();
                        });

                });  // end describe

		// Variable para rastrear el estado de los tests
                let allTestsPassed = true;	
                // Run Mocha tests
                mocha.run()
                    .on('test', function(test) {
                        logToConsole('‚Ä¢ Running test: ' + test.title);
                    })
                    .on('test end', function(test) {
                        logToConsole('‚Ä¢ Test finished: ' + test.title);
                    })
                    .on('pass', function(test) {
                        logToConsole('‚Ä¢ Test passed: ' + test.title);
                    })
                    .on('fail', function(test, err) {
			logToConsole('‚Ä¢ Test failed: ' + test.title + ' - ' + err.message);
			success_message = modal_click_message;
			const runButton = document.getElementById('run-button');
			runButton.innerText = 'Retry';
			runButton.style.backgroundColor = '#ff0000ad';
			runButton.onclick = function() {
			    window.location.reload();
			};	    
			allTestsPassed = false; // Si cualquier test falla, actualizamos la variable	
		     })
		     .on('end', function() {
			logToConsole('‚Ä¢ All tests finished!');
			document.getElementById('modify-message').innerText = success_message;
			document.getElementById('modify-message').style.display = 'block';
			document.getElementById('modify-message').style.color = 'black';
			 if (allTestsPassed) {
		               const sendResponseButton = document.getElementById('send-response-button');
		               sendResponseButton.classList.add('enabled');
		        } 
		     });

            } catch (e) {
                console.error('Error evaluating user code:', e);
                logToConsole('Error: ' + e.message, 'red');
            } finally {
                // Restore original console.log
                console.log = originalConsoleLog;
            }
			
		}, 3000); // 3 seconds delay
        });
    }
	    
    async function guardarResultados() {
	    const formData = JSON.parse(localStorage.getItem("formData"));
	    const email = formData ? formData.Email : null;
            const recipeId = localStorage.getItem('recipeId'); // Recuperar recipeId de local storage
	    // Crear el objeto que se guardar√° en la base de datos
	    // Obtener la URL actual
	    const currentUrl = window.location.href;
	    // Crear un objeto URL
	    const url = new URL(currentUrl);
	    // Eliminar el par√°metro 'token' de la query string
	    url.searchParams.delete('token');
	    // Obtener el pathname sin el token
            const urlWithoutToken = url.pathname.split('/').pop();
	    const recipeCalificadaOk = {
	        recipeId: recipeId,
		url: urlWithoutToken,
	        date: new Date().toISOString()
	    };
	    try {
	        const response = await fetch('https://www.refactorii.com/updateOneGoogleSigninUserRecipe', {
	            method: 'POST',
	            headers: {
	                'Content-Type': 'application/json'
	            },
	            //body: JSON.stringify({ Email: email, recipeCalificadaOk: recipeId })
		    body: JSON.stringify({ Email: email, recipeCalificadaOk })	
	        });
	        const data = await response.json();
	        console.log('Server responds:', "Ok");
		// Redirecci√≥n a la p√°gina original
                window.location.href = `https://www.refactorii.com/recipes/${recipeId}`;
	    } catch (error) {
	        console.error('Error sending the results to the server:', error);
	    }
    }

    function decodeJwtResponse(token) {
	    var base64Url = token.split('.')[1];
	    var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
	    var jsonPayload = decodeURIComponent(window.atob(base64).split('').map(function(c) {
	        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	    }).join(''));
	    return JSON.parse(jsonPayload);
    }
    </script>
</body>
</html>
